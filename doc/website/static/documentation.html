<!DOCTYPE html>
<html>

  <head>
    <title>Node.js</title>
    <link rel="stylesheet" type="text/css" href="styles/reset.css">
    <link rel="stylesheet" type="text/css" href="styles/style.css">
    <link rel="stylesheet" href="styles/prettify.css" type="text/css" media="screen" title="no title" charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  </head>

  <body class="green">
    <div id="wrapper">

      <div id="header" class="section">
        <div id="logo"><a href="/">Node.js</a></div>
        <ul id="nav">
          <li class="navitem"><a href="about.html">About</a></li>
          <li class="navitem"><a href="documentation.html">Documentation</a></li>
          <li class="navitem"><a href="benchmarks.html">Benchmarks</a></li>
          <li class="navitem"><a href="contributions.html">Contributions</a></li>
          <li class="navitem"><a href="resources.html">Resources</a></li>
          <li class="navitem themetext"><a id="toggleirc" href="#">Read the IRC Channel</a></li>
        </ul>
      </div> <!-- end #header -->

      <div id="irc" class="section"><div class="console"></div></div>

      <div id="content" class="section">

	<div id="man-sidebar">
	  <div class="shadow">
	    <div id="toc" class="shadowed">
	      <noscript>JavaScript must be enabled in your browser to
		display the table of contents.</noscript>
	    </div>
	  </div>

	  <a id="print-documentation" class="callout"
	     href="#print">Print Documentation</a>

	</div> <!-- end #sidebar -->

	<div id="man">
	  <div id="man-content">
	    <h1>Documentation</h1>

	    <h2 id="Name">Name</h2>
	    <p>node(1) -- evented I/O for V8 JavaScript</p>

	    <div id="current-section" class="header"><!-- see navUpdater() --></div>

	    <!-- end documentation header -->

<h2 id="Synopsis">Synopsis</h2>

<p>An example of a web server written with Node which responds with 'Hello
World':</p>

<pre class="prettyprint"><code>var http = require('http');

http.createServer(function (request, response) {
  response.writeHead(200, {'Content-Type': 'text/plain'});
  response.end('Hello World\n');
}).listen(8124);

console.log('Server running at http://127.0.0.1:8124/');</code></pre>

<p>To run the server, put the code into a file called <code>example.js</code> and execute
it with the node program</p>

<pre class="prettyprint"><code>&gt; node example.js
Server running at http://127.0.0.1:8124/</code></pre>

<p>All of the examples in the documentation can be run similarly.</p>

<h2 id="Standard Modules">Standard Modules</h2>

<p>Node comes with a number of modules that are compiled in to the process,
most of which are documented below.  The most common way to use these modules
is with <code>require('name')</code> and then assigning the return value to a local
variable with the same name as the module.</p>

<p>Example:</p>

<pre class="prettyprint"><code>var sys = require('sys');</code></pre>

<p>It is possible to extend node with other modules.  See <code>'Modules'</code></p>

<h2 id="Buffers">Buffers</h2>

<p>Pure Javascript is Unicode friendly but not nice to binary data.  When
dealing with TCP streams or the file system, it's necessary to handle octet
streams. Node has several strategies for manipulating, creating, and
consuming octet streams.</p>

<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar
to an array of integers but corresponds to a raw memory allocation outside
the V8 heap. A <code>Buffer</code> cannot be resized.
Access the class with <code>require('buffer').Buffer</code>.</p>

<p>Converting between Buffers and JavaScript string objects requires an explicit encoding
method.  Node supports 3 string encodings: UTF-8 (<code>'utf8'</code>), ASCII (<code>'ascii'</code>), and
Binary (<code>'binary'</code>).</p>

<ul><li><p><code>'ascii'</code> - for 7 bit ASCII data only.  This encoding method is very fast, and will
strip the high bit if set.</p></li><li><p><code>'utf8'</code> - Unicode characters.  Many web pages and other document formats use UTF-8.</p></li><li><p><code>'base64'</code> - Base64 string encoding.</p></li><li><p><code>'binary'</code> - A legacy encoding. Used to store raw binary data in a string
by only using the first 8 bits of every character. Don't use this.</p></li></ul>

<h3>new Buffer(size)</h3>

<p>Allocates a new buffer of <code>size</code> octets.</p>

<h3>new Buffer(array)</h3>

<p>Allocates a new buffer using an <code>array</code> of octets.</p>

<h3>new Buffer(str, encoding='utf8')</h3>

<p>Allocates a new buffer containing the given <code>str</code>.</p>

<h3>buffer.write(string, offset=0, encoding='utf8')</h3>

<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding. Returns
number of octets written.  If <code>buffer</code> did not contain enough space to fit
the entire string it will write a partial amount of the string. In the case
of <code>'utf8'</code> encoding, the method will not write partial characters.</p>

<p>Example: write a utf8 string into a buffer, then print it</p>

<pre class="prettyprint"><code>Buffer = require('buffer').Buffer;
buf = new Buffer(256);
len = buf.write('\u00bd + \u00bc = \u00be', 0);
console.log(len + " bytes: " + buf.toString('utf8', 0, len));

// 12 bytes: ½ + ¼ = ¾</code></pre>

<h3>buffer.toString(encoding, start=0, end=buffer.length)</h3>

<p>Decodes and returns a string from buffer data encoded with <code>encoding</code>
beginning at <code>start</code> and ending at <code>end</code>.</p>

<p>See <code>buffer.write()</code> example, above.</p>

<h3>buffer[index]</h3>

<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,
so the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.</p>

<p>Example: copy an ASCII string into a buffer, one byte at a time:</p>

<pre class="prettyprint"><code>var Buffer = require('buffer').Buffer,
  str = "node.js",
  buf = new Buffer(str.length),
  i;

for (i = 0; i &lt; str.length ; i += 1) {
  buf[i] = str.charCodeAt(i);
}

console.log(buf);

// node.js</code></pre>

<h3>Buffer.byteLength(string, encoding='utf8')</h3>

<p>Gives the actual byte length of a string.  This is not the same as
<code>String.prototype.length</code> since that returns the number of <em>characters</em> in a
string.</p>

<p>Example:</p>

<pre class="prettyprint"><code>var Buffer = require('buffer').Buffer,
  str = '\u00bd + \u00bc = \u00be';

console.log(str + ": " + str.length + " characters, " +
  Buffer.byteLength(str, 'utf8') + " bytes");

// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>

<h3>buffer.length</h3>

<p>The size of the buffer in bytes.  Note that this is not necessarily the size
of the contents. <code>length</code> refers to the amount of memory allocated for the
buffer object.  It does not change when the contents of the buffer are changed.</p>

<pre class="prettyprint"><code>var Buffer = require('buffer').Buffer,
  buf = new Buffer(1234);

console.log(buf.length);
buf.write("some string", "ascii", 0);
console.log(buf.length);

// 1234
// 1234</code></pre>

<h3>buffer.copy(targetBuffer, targetStart, sourceStart, sourceEnd=buffer.length)</h3>

<p>Does a memcpy() between buffers.</p>

<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19
into <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.</p>

<pre class="prettyprint"><code>var Buffer = require('buffer').Buffer,
  buf1 = new Buffer(26),
  buf2 = new Buffer(26),
  i;

for (i = 0 ; i &lt; 26 ; i += 1) {
  buf1[i] = i + 97; // 97 is ASCII a
  buf2[i] = 33; // ASCII !
}

buf1.copy(buf2, 8, 16, 20);
console.log(buf2.toString('ascii', 0, 25));

// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>

<h3>buffer.slice(start, end)</h3>

<p>Returns a new buffer which references the
same memory as the old, but offset and cropped by the <code>start</code> and <code>end</code>
indexes.</p>

<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong></p>

<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one byte
from the original Buffer.</p>

<pre class="prettyprint"><code>var Buffer = require('buffer').Buffer,
  buf1 = new Buffer(26), buf2,
  i;

for (i = 0 ; i &lt; 26 ; i += 1) {
  buf1[i] = i + 97; // 97 is ASCII a
}

buf2 = buf1.slice(0, 3);
console.log(buf2.toString('ascii', 0, buf2.length));
buf1[0] = 33;
console.log(buf2.toString('ascii', 0, buf2.length));

// abc
// !bc</code></pre>

<h2 id="EventEmitter">EventEmitter</h2>

<p>Many objects in Node emit events: a TCP server emits an event each time
there is a stream, a child process emits an event when it exits. All
objects which emit events are instances of <code>events.EventEmitter</code>.</p>

<p>Events are represented by a camel-cased string. Here are some examples:
<code>'stream'</code>, <code>'data'</code>, <code>'messageBegin'</code>.</p>

<p>Functions can be then be attached to objects, to be executed when an event
is emitted. These functions are called <em>listeners</em>.</p>

<p><code>require('events').EventEmitter</code> to access the <code>EventEmitter</code> class.</p>

<p>All EventEmitters emit the event <code>'newListener'</code> when new listeners are
added.</p>

<p>When an EventEmitter experiences an error, the typical action is to emit an
<code>'error'</code> event.  Error events are special--if there is no handler for them
they will print a stack trace and exit the program.</p>

<h3>Event: 'newListener'</h3>

<p><code>function (event, listener) { }</code></p>

<p>This event is emitted any time someone adds a new listener.</p>

<h3>Event: 'error'</h3>

<p><code>function (exception) { }</code></p>

<p>If an error was encountered, then this event is emitted. This event is
special - when there are no listeners to receive the error Node will
terminate execution and display the exception's stack trace.</p>

<h3>emitter.on(event, listener)</h3>

<p>Adds a listener to the end of the listeners array for the specified event.</p>

<pre class="prettyprint"><code>server.on('stream', function (stream) {
  console.log('someone connected!');
});</code></pre>

<h3>emitter.removeListener(event, listener)</h3>

<p>Remove a listener from the listener array for the specified event.
<strong>Caution</strong>: changes array indices in the listener array behind the listener.</p>

<pre class="prettyprint"><code>var callback = function(stream) {
  console.log('someone connected!');
};
server.on('stream', callback);
// ...
server.removeListener('stream', callback);</code></pre>

<h3>emitter.removeAllListeners(event)</h3>

<p>Removes all listeners from the listener array for the specified event.</p>

<h3>emitter.listeners(event)</h3>

<p>Returns an array of listeners for the specified event. This array can be
manipulated, e.g. to remove listeners.</p>

<pre class="prettyprint"><code>server.on('stream', function (stream) {
  console.log('someone connected!');
});
console.log(sys.inspect(server.listeners('stream'));
// [ [Function] ]</code></pre>

<h3>emitter.emit(event, [arg1], [arg2], [...])</h3>

<p>Execute each of the listeners in order with the supplied arguments.</p>

<h2 id="Streams">Streams</h2>

<p>A stream is an abstract interface implemented by various objects in Node.
For example a request to an HTTP server is a stream, as is stdout. Streams
are readable, writable, or both. All streams are instances of <code>EventEmitter</code>.</p>

<h2 id="Readable Stream">Readable Stream</h2>

<p>A <code>Readable Stream</code> has the following methods, members, and events.</p>

<h3>Event: 'data'</h3>

<p><code>function (data) { }</code></p>

<p>The <code>'data'</code> event emits either a <code>Buffer</code> (by default) or a string if
<code>setEncoding()</code> was used.</p>

<h3>Event: 'end'</h3>

<p><code>function () { }</code></p>

<p>Emitted when the stream has received an EOF (FIN in TCP terminology).
Indicates that no more <code>'data'</code> events will happen. If the stream is also
writable, it may be possible to continue writing.</p>

<h3>Event: 'error'</h3>

<p><code>function (exception) { }</code></p>

<p>Emitted if there was an error receiving data.</p>

<h3>Event: 'close'</h3>

<p><code>function () { }</code></p>

<p>Emitted when the underlying file descriptor has be closed. Not all streams
will emit this.  (For example, an incoming HTTP request will not emit
<code>'close'</code>.)</p>

<h3>Event: 'fd'</h3>

<p><code>function (fd) { }</code></p>

<p>Emitted when a file descriptor is received on the stream. Only UNIX streams
support this functionality; all others will simply never emit this event.</p>

<h3>stream.readable</h3>

<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>'error'</code>

occured, the stream came to an <code>'end'</code>, or <code>destroy()</code> was called.</p>

<h3>stream.setEncoding(encoding)</h3>

<p>Makes the data event emit a string instead of a <code>Buffer</code>. <code>encoding</code> can be

<code>'utf8'</code>, <code>'ascii'</code>, or <code>'binary'</code>.</p>

<h3>stream.pause()</h3>

<p>Pauses the incoming <code>'data'</code> events.</p>

<h3>stream.resume()</h3>

<p>Resumes the incoming <code>'data'</code> events after a <code>pause()</code>.</p>

<h3>stream.destroy()</h3>

<p>Closes the underlying file descriptor. Stream will not emit any more events.</p>

<h2 id="Writable Stream">Writable Stream</h2>

<p>A <code>Writable Stream</code> has the following methods, members, and events.</p>

<h3>Event: 'drain'</h3>

<p><code>function () { }</code></p>

<p>Emitted after a <code>write()</code> method was called that returned <code>false</code> to
indicate that it is safe to write again.</p>

<h3>Event: 'error'</h3>

<p><code>function (exception) { }</code></p>

<p>Emitted on error with the exception <code>exception</code>.</p>

<h3>Event: 'close'</h3>

<p><code>function () { }</code></p>

<p>Emitted when the underlying file descriptor has been closed.</p>

<h3>stream.writeable</h3>

<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>'error'</code>
occurred or <code>end()</code> / <code>destroy()</code> was called.</p>

<h3>stream.write(string, encoding='utf8', [fd])</h3>

<p>Writes <code>string</code> with the given <code>encoding</code> to the stream.  Returns <code>true</code> if
the string has been flushed to the kernel buffer.  Returns <code>false</code> to
indicate that the kernel buffer is full, and the data will be sent out in
the future. The <code>'drain'</code> event will indicate when the kernel buffer is
empty again. The <code>encoding</code> defaults to <code>'utf8'</code>.</p>

<p>If the optional <code>fd</code> parameter is specified, it is interpreted as an integral
file descriptor to be sent over the stream. This is only supported for UNIX
streams, and is silently ignored otherwise. When writing a file descriptor in
this manner, closing the descriptor before the stream drains risks sending an
invalid (closed) FD.</p>

<h3>stream.write(buffer)</h3>

<p>Same as the above except with a raw buffer.</p>

<h3>stream.end()</h3>

<p>Terminates the stream with EOF or FIN.</p>

<h3>stream.end(string, encoding)</h3>

<p>Sends <code>string</code> with the given <code>encoding</code> and terminates the stream with EOF
or FIN. This is useful to reduce the number of packets sent.</p>

<h3>stream.end(buffer)</h3>

<p>Same as above but with a <code>buffer</code>.</p>

<h3>stream.destroy()</h3>

<p>Closes the underlying file descriptor. Stream will not emit any
  more events.</p>

            <!-- begin documentation footer -->

	    <div id="last-header" class="header"><!-- see navUpdater() --></div>
	  </div>
	</div> <!-- end #main -->

      </div><!-- end #content -->

      <div id="footer" class="section">
	<span id="copyright">&copy;2010 NODE.JS All rights
	reserved. Site by <a href="http://thisismedium.com"
	class="themetext">medium.</a></span>

        <ul id="bottomnav">
          <li class="navitem"><a href="about.html">About</a></li>
          <li class="navitem"><a href="documentation.html">Documentation</a></li>
          <li class="navitem"><a href="benchmarks.html">Benchmarks</a></li>
          <li class="navitem"><a href="contributions.html">Contributions</a></li>
          <li class="navitem"><a href="resources.html">Resources</a></li>
        </ul>
      </div> <!-- end #footer -->

    </div><!-- end #wrapper -->

    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
    <script src="js/prettify.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" src="js/site.js"></script>

  </body>
</html>
